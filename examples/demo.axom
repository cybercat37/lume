println "*** variables and mutation ***"
let mut counter = 1
println "counter start"
println counter

counter = counter + 2
println "counter updated"
println counter

println "*** blocks and scope ***"
{
  let x = 10
  let y = 20
  println "block sum"
  println x + y
}

println "*** strings and builtins ***"
let greeting = "hi"
println "string concat"
println greeting + " there"
println "len(greeting)"
print len(greeting)

println "*** functions and lambdas ***"
fn add(x: Int, y: Int) -> Int => x + y
let inc = fn(x: Int) => x + 1
fn double(x: Int) -> Int {
  return x * 2
}
println add(1, 2)
println inc(3)
println double(4)

println "*** numeric builtins (int + float) ***"
let m = max(2, abs(-3))
println m
println min(1, 2)
println abs(-1.5)
println min(1.5, 2.5)
println max(1.5, 2.5)

println "*** records ***"
type User { name: String, age: Int }
let user = User { name: "Ada", age: 36 }
println "record field"
println user.name

println "*** sum types and match ***"
type Result { Ok(Int) Err(String) }
let value = Ok(42)
print match value {
  Ok(x) -> x
  Err(_) -> 0
}

println "*** tuples and match ***"
println match (1, 2) {
  (a, b) -> a + b
  _ -> 0
}

println "*** tuple destructuring (let) ***"
let (left, right) = (10, 20)
println left + right

println "*** tuple types in signatures ***"
fn swap(pair: (Int, String)) -> (String, Int) => ("ok", 1)
println swap((1, "x"))

println "*** input (commented) ***"
println "// input() is available but skipped in demo"

println "*** operators ***"
println "comparisons"
println 1 + 2 == 3
println 4 <= 2
println "logical"
println true || false && true
println "float arithmetic"
println 1.5 + 2.25

println "*** numeric conversions ***"
println float(2)
println int(3.9)

println "*** recursion ***"
fn fib(n: Int) -> Int => match n {
  0 -> 0
  1 -> 1
  _ -> fib(n - 1) + fib(n - 2)
}

fn fact(n: Int) -> Int => match n {
  0 -> 1
  1 -> 1
  _ -> n * fact(n - 1)
}

println "*** record patterns + guards ***"
print match user {
  User { name: n, age: a } if a > 40 -> "old"
  User { name: n, age: a } if a > 30 -> n
  _ -> "other"
}

println "*** list literals ***"
println [1, 2, 3]
println ["a", "b", "c"]
println [1.5, 2.25, 3.75]
println "*** list indexing ***"
println [10, 20, 30][1]
println "*** map literals ***"
println ["a": 1, "b": 2]
println ["ok": true, "err": false]
println "*** option/result + ? + unwrap ***"
type Option { Some(Int) None }

fn maybe(x: Int) -> Option => match x {
  0 -> None
  _ -> Some(x)
}

fn add_one(x: Int) -> Option {
  let value = maybe(x)?
  return Some(value + 1)
}

fn parse(x: Int) -> Result => match x {
  0 -> Err("bad")
  _ -> Ok(x)
}

fn add_one_result(x: Int) -> Result {
  let value = parse(x)?
  return Ok(value + 1)
}

println add_one(0)
println add_one(2)
println add_one_result(0)
println add_one_result(2)
println Some(2).unwrap()

println fib(8)
println fact(5)
